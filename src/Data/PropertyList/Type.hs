{-# LANGUAGE 
    MultiParamTypeClasses, FunctionalDependencies,
    TemplateHaskell,
    FlexibleContexts, FlexibleInstances, UndecidableInstances, 
    OverlappingInstances, IncoherentInstances,
    GeneralizedNewtypeDeriving
  #-}

-- |The interface of this module is very heavily influenced by category-theoretical
-- constructions.  In particular, F-algebras and F-coalgebras, initiality, and
-- terminality.
-- 
-- For those not familiar with these concepts, this will probably be quite
-- incomprehensible.  Sorry about that.  The basic idea, though, is the use of
-- the 'PropertyListS' type as a sort of a central junction point through which
-- all conversions between property-list-like types and property-list-item 
-- types are routed.  The classes defined here are chosen to minimize the
-- inderdependence of these types and hence maximize the flexibility of the
-- system as a whole.
--
-- Even more simply stated, these weird math thingies make the design
-- as flexible as possible.
module Data.PropertyList.Type where

import Control.Functor.Pointed
import Control.Functor.Fix
import Control.Applicative
import Control.Monad.Identity
import Control.Monad.Free
import Data.Foldable (Foldable(foldMap))
import Data.Traversable (Traversable(..))
import Data.Monoid
import Data.Void

import Language.Haskell.TH.Fold (fold)
import Unsafe.Coerce (unsafeCoerce) {- used _only_ to eliminate fmap traversals for newtype constructors -}

import qualified Data.Map as M
import Data.ByteString as B hiding (map)
import Data.Time

-- * The 'PropertyListS' signature type

-- |The signature of the base property list algebra.  This algebra is 
-- \"lifted\" in various ways to support several different but similar
-- representations of property lists as well as projections and
-- injections.  All the different representations are 'connected' through
-- this signature.
-- 
-- For example, 'PropertyList' is a fixed-point of this signature - that
-- is, a recursive version where @a@ is instantiated as @'PropertyListS' a@.
-- That gives the \"expected\" structure of a basic property list.  It is both
-- initial and terminal for this signature in its 'un-lifted' form - which
-- is to say, any other type with an algebra for this signature (such as an 
-- XML representation) can be made from a 'PropertyList', and any type with
-- a coalgebra for this signature (such as a 'String', an 'Integer', etc.)
-- can be converted directly to a 'PropertyList'.
--
-- Similarly, 'PartialPropertyList' is a fixed point of an arbitrarily-
-- augmented version of this signature (also known as the free monad 
-- generated by the signature).  Depending on its type parameter, 
-- 'PartialPropertyList' can be terminal among many simple extensions to 
-- the signature.  Thus many types with a coalgebra for an extension of 
-- this signature (such as XML given an appropriate tree destructor, or 
-- the 'PropertyList' type itself)  can be trivially converted to a 
-- 'PartialPropertyList'.
data PropertyListS a
    = PLArray [a]
    | PLData ByteString
    | PLDate UTCTime
    | PLDict  (M.Map String a)
    | PLReal Double
    | PLInt Integer
    | PLString String
    | PLBool Bool
    deriving (Eq, Ord, Show, Read)

-- |Construct a basic non-recursive algebra of property list items.
-- This is equivalent to pattern matching on 'PropertyListS'.
foldPropertyListS :: ([a] -> t)
                  -> (ByteString -> t)
                  -> (UTCTime -> t)
                  -> (M.Map String a -> t)
                  -> (Double -> t)
                  -> (Integer -> t)
                  -> (String -> t)
                  -> (Bool -> t) 
                  -> PropertyListS a -> t
foldPropertyListS = $(fold ''PropertyListS)

instance Functor PropertyListS where
    fmap f = foldPropertyListS (PLArray . fmap f) PLData PLDate (PLDict . fmap f) PLReal PLInt PLString PLBool

instance Foldable PropertyListS where
    foldMap f = foldPropertyListS (foldMap f) mempty mempty (foldMap f) mempty mempty mempty mempty

instance Traversable PropertyListS where
    sequenceA = foldPropertyListS (fmap PLArray . sequenceA) (pure . PLData) (pure . PLDate) (fmap PLDict . sequenceA) (pure . PLReal) (pure . PLInt) (pure . PLString) (pure . PLBool)

-- * The algebra and coalgebra classes

-- |A class for types with chosen lifted property list algebra.
-- The lifting is provided to support extending the algebra.  It is provided
-- in a class because most of the time for any given type there is only
-- one algebra you care about.
class Functor f => PListAlgebra f a where
    -- |Build a value of type @a@ from a piece of a property list (using
    -- the 'PropertyListS' signature augmented by the \"lifting\" @f@).
    plistAlgebra :: f (PropertyListS a) -> a

-- |An identification of the fact that the type @a@ has an initial plist algebra
-- (under some lifting @f@).  Functional dependencies are in use - for any 
-- type, only one of its initial algebras (if multiple apply, which they may
-- because the same type may be initial for multiple distinct liftings)
-- can be chosen, and for any lifting only one type's algebra may be chosen.
-- This is to make types decidable in the not-so-uncommon case where the
-- lifting is encapsulated (eg, any time 'foldPList' is partially applied
-- - for example, see the signature of 'fromPlist').
-- 
-- For cases where the lifting either needs to be chosen or needs to be
-- transformed to another lifting, 'fromPlistWith' is provided.  It is based
-- on the same definition as the default implementation of 'foldPList' but
-- also inserts a chosen transformation of the lifting.
-- 
-- Question for self: Is the PListCoalgebra context reasonable here?  
-- Some rough calculations suggest that in the presence of fixed point 
-- type operators, it is possible to construct a PListCoalgebra for any 
-- InitialPList, which essentially is defined as pattern matching.  So, 
-- I'm not totally sure but I think this is reasonable - at least, for
-- finitary signatures, which we're using as long as @f@ doesn't go crazy.
class (PListAlgebra f a, PListCoalgebra f a) => InitialPList f a | f -> a, a -> f where
    -- |Using some other plist algebra, compute the unique transformation from
    -- the type @a@ to that algebra.
    -- 
    -- The default implementation is:
    --
    -- > foldPList f = go
    -- >    where
    -- >        go = f . fmap (fmap go) . plistCoalgebra
    --
    foldPList :: (f (PropertyListS t) -> t) -> a -> t
    foldPList f = go
        where
            go = f . fmap (fmap go) . plistCoalgebra

-- |Convert from an initial plist to any other plist with the same lifted algebra.
fromPlist :: (InitialPList f pl, PListAlgebra f t) => pl -> t
fromPlist = foldPList plistAlgebra

-- If the transformation is natural, this is equivalent to 'toPlistWith'.  I think.
fromPlistWith :: (PListCoalgebra f pl, PListAlgebra g t) => (f (PropertyListS t) -> g (PropertyListS t)) -> pl -> t
fromPlistWith lift = fold
    where
        fold = plistAlgebra . lift . fmap (fmap fold) . plistCoalgebra

-- |A class for types with chosen lifted property list coalgebra.
-- The lifting is provided to support extending the coalgebra.
class Functor f => PListCoalgebra f a where
    -- |Analyze a value of type @a@ by matching it to a constructor in the
    -- (lifted by @f@) 'PropertyListS' signature.
    plistCoalgebra :: a -> f (PropertyListS a)

-- |Chosen terminal coalgebra for the given lifting, and chosen lifting
-- for the given type.  See also 'InitialPList'.
class (PListCoalgebra f a, PListAlgebra f a) => TerminalPList f a | f -> a, a -> f where
    -- |Given some coalgebra for the chosen lifted plist signature, compute
    -- the unique extraction/unfolding of that coalgebra into the type @a@.
    -- 
    -- The default implementation is:
    -- 
    -- > unfoldPList f = go
    -- >     where
    -- >         go = plistAlgebra . fmap (fmap go) . f
    -- 
    unfoldPList :: (t -> f (PropertyListS t)) -> t -> a
    unfoldPList f = go
        where
            go = plistAlgebra . fmap (fmap go) . f

-- |Convert from any plist-like thing to a plist which is terminal for a some lifted algebra.
toPlist :: (PListCoalgebra f t, TerminalPList f pl) => t -> pl
toPlist = unfoldPList plistCoalgebra

-- If the transformation is natural, this is equivalent to 'fromPlistWith'.  I think.
toPlistWith :: (PListCoalgebra f t, PListAlgebra g pl) => (f (PropertyListS t) -> g (PropertyListS t)) -> t -> pl
toPlistWith lift = unfold
    where
        unfold = plistAlgebra . fmap (fmap unfold) . lift . plistCoalgebra
        

-- * \"Smart\" constructors for any 'PListAlgebra'.

plArray :: (PListAlgebra Identity a) => [a] -> a
plArray     x   = plistAlgebra (Identity $ PLArray  x)

plData :: (PListAlgebra Identity a) => ByteString -> a
plData      x   = plistAlgebra (Identity $ PLData   x)

plDate :: (PListAlgebra Identity a) => UTCTime -> a
plDate      x   = plistAlgebra (Identity $ PLDate   x)

plDict :: (PListAlgebra Identity a) => M.Map String a -> a
plDict      x   = plistAlgebra (Identity $ PLDict   x)

plReal :: (PListAlgebra Identity a) => Double -> a
plReal      x   = plistAlgebra (Identity $ PLReal   x)

plInt :: (PListAlgebra Identity a) => Integer -> a
plInt       x   = plistAlgebra (Identity $ PLInt    x)

plString :: (PListAlgebra Identity a) => String -> a
plString    x   = plistAlgebra (Identity $ PLString x)

plBool :: (PListAlgebra Identity a) => Bool -> a
plBool      x   = plistAlgebra (Identity $ PLBool   x)

-- * \"View pattern\" destructors for any 'PListCoalgebra'.

fromPlArray :: PListCoalgebra Maybe a => a -> Maybe [a]
fromPlArray pl = do PLArray a <- plistCoalgebra pl; return a

fromPlData :: PListCoalgebra Maybe a => a -> Maybe ByteString
fromPlData pl = do PLData a <- plistCoalgebra pl; return a

fromPlDate :: PListCoalgebra Maybe a => a -> Maybe UTCTime
fromPlDate pl = do PLDate a <- plistCoalgebra pl; return a

fromPlDict :: PListCoalgebra Maybe a => a -> Maybe (M.Map String a)
fromPlDict pl = do PLDict a <- plistCoalgebra pl; return a

fromPlReal :: PListCoalgebra Maybe a => a -> Maybe Double
fromPlReal pl = do PLReal a <- plistCoalgebra pl; return a

fromPlInt :: PListCoalgebra Maybe a => a -> Maybe Integer
fromPlInt pl = do PLInt a <- plistCoalgebra pl; return a

fromPlString :: PListCoalgebra Maybe a => a -> Maybe String
fromPlString pl = do PLString a <- plistCoalgebra pl; return a

fromPlBool :: PListCoalgebra Maybe a => a -> Maybe Bool
fromPlBool pl = do PLBool a <- plistCoalgebra pl; return a

-- * The 'PropertyList' data type
-- (the universal algebra/coalgebra for the unlifted signature)

-- |A fully-parsed property list.
newtype PropertyList = PL { unPL :: FixF PropertyListS }
instance Eq PropertyList where
    PL (InF x) == PL (InF y) = fmap PL x == fmap PL y
instance Ord PropertyList where
    PL (InF x) `compare` PL (InF y) = fmap PL x `compare` fmap PL y

{-# RULES
    -- don't traverse with no-ops!
"fmap PL   -> unsafeCoerce"     fmap PL   = unsafeCoerce
"fmap unPl -> unsafeCoerce"     fmap unPL = unsafeCoerce
  #-}

instance Show PropertyList where
    show pl = showsPrec 0 pl " :: PropertyList"
    showsPrec p (PL x) = showParen (p > 10) $ case outF x of
        PLArray  arr  -> showString "plArray "  . showsPrec 11 (fmap PL arr)
        PLData   bs   -> showString "plData "   . showsPrec 11 bs  
        PLDate   time -> showString "plDate "   . showsPrec 11 time
        PLDict   dict -> showString "plDict "   . showsPrec 11 (fmap PL dict)
        PLReal   dbl  -> showString "plReal "   . showsPrec 11 dbl 
        PLInt    int  -> showString "plInt "    . showsPrec 11 int 
        PLString str  -> showString "plString " . showsPrec 11 str 
        PLBool   bool -> showString "plBool "   . showsPrec 11 bool

instance Copointed f => PListAlgebra f PropertyList where
    {-# SPECIALIZE instance PListAlgebra Identity PropertyList #-}
    plistAlgebra = PL . InF . fmap unPL . extract

instance PListCoalgebra Identity a => PListAlgebra (Either a) PropertyList where
    plistAlgebra = either toPlist (plistAlgebra . Identity)

instance InitialPList Identity PropertyList

instance Pointed f => PListCoalgebra f PropertyList where
    {-# SPECIALIZE instance PListCoalgebra Identity PropertyList #-}
    plistCoalgebra = point . fmap PL . outF . unPL

instance TerminalPList Identity PropertyList

foldPropertyList f (PL pl) = fold pl
    where fold (InF x) = f (fmap fold x)

-- * The 'PartialPropertyList' data type
-- (the universal algebra/coalgebra for the signature extended by 
--  introducing new constructors)

-- |A partially-parsed property-list term algebra, parameterized over the type of
-- \"structural holes\" in the terms.
newtype PartialPropertyList a = PPL {unPPL :: Free PropertyListS a}
    deriving (Pointed, Functor, Monad, MonadFree PropertyListS)
{-# RULES
    -- don't traverse with no-ops!
"fmap PPL   -> unsafeCoerce"     fmap PPL   = unsafeCoerce
"fmap unPPl -> unsafeCoerce"     fmap unPPL = unsafeCoerce
  #-}

instance Applicative PartialPropertyList where
    pure = return
    (<*>) = ap

instance Foldable PartialPropertyList where
    foldMap f (PPL x) = case runFree x of
        Left  x -> f x
        Right x -> foldMap (foldMap f . PPL) x

instance Traversable PartialPropertyList where
    traverse f (PPL x) = case runFree x of
        Left x  -> return <$> f x
        Right x -> inFree <$> traverse (traverse f . PPL) x

instance Eq a => Eq (PartialPropertyList a) where
    PPL x == PPL y = case (runFree x, runFree y) of
        (Left a,  Left  b) -> a == b
        (Right a, Right b) -> fmap PPL a == fmap PPL b
        _                  -> False

instance Ord a => Ord (PartialPropertyList a) where
    PPL x `compare` PPL y = case (runFree x, runFree y) of
        (Left a,  Left  b) -> a `compare` b
        (Left _,  Right _) -> Left () `compare` Right ()
        (Right a, Right b) -> fmap PPL a `compare` fmap PPL b
        (Right _, Left  _) -> Right () `compare` Left ()

instance Show a => Show (PartialPropertyList a) where
    showsPrec p (PPL x) = showParen (p > 10) $ case runFree x of
        Left a ->  showString "return " . showsPrec 11 a
        Right x -> case x of
            PLArray  arr  -> showString "plArray "  . showsPrec 11 (fmap PPL arr)
            PLData   bs   -> showString "plData "   . showsPrec 11 bs  
            PLDate   time -> showString "plDate "   . showsPrec 11 time
            PLDict   dict -> showString "plDict "   . showsPrec 11 (fmap PPL dict)
            PLReal   dbl  -> showString "plReal "   . showsPrec 11 dbl 
            PLInt    int  -> showString "plInt "    . showsPrec 11 int 
            PLString str  -> showString "plString " . showsPrec 11 str 
            PLBool   bool -> showString "plBool "   . showsPrec 11 bool

-- instance Read...


-- this instance overlaps (with incoherence allowed) with all 
-- others for PartialPropertyList: ensure that you don't define 
-- an explicit instance for any 'Copointed' functor!
instance Copointed f => PListAlgebra f (PartialPropertyList a) where
    {-# SPECIALIZE instance PListAlgebra Identity (PartialPropertyList a) #-}
    plistAlgebra = inFree . extract

instance PListAlgebra Maybe (PartialPropertyList ()) where
    plistAlgebra Nothing  = return ()
    plistAlgebra (Just x) = inFree x

instance PListAlgebra (Either a) (PartialPropertyList a) where
    plistAlgebra (Left  x) = return x
    plistAlgebra (Right x) = inFree x

instance InitialPList (Either a) (PartialPropertyList a) where

instance PListCoalgebra (Either a) (PartialPropertyList a) where
    plistCoalgebra (PPL xf) = fmap (fmap PPL) (runFree xf)

instance TerminalPList (Either a) (PartialPropertyList a) where

instance PListCoalgebra Maybe (PartialPropertyList a) where
    plistCoalgebra (PPL xf) = case runFree xf of
        Left  _ -> Nothing
        Right x -> Just (fmap PPL x)

-- * Convenient functions for converting from 'PartialPropertyList' to
-- 'PropertyList'.

-- |Take a 'PartialPropertyList' that has been expunged of all incomplete
-- elements (as witnessed by the 'PListCoalgebra' 'Identity' @a@ context, which
-- states that any value of type @a@ can be unfolded to a complete 'PropertyList')
-- and convert it to a 'PropertyList'.
--
-- This is just a convenient synonym for 'fromPlist' with the types
-- explicitly specialized.
completePropertyList :: PListCoalgebra Identity a => PartialPropertyList a -> PropertyList
completePropertyList = fromPlist

-- |Like 'completePropertyList' but also accepting a function that \"attempts\"
-- to complete any incomplete value in the 'PartialPropertyList'.
-- 
-- Note that there is a potential type-inference trap here - the @b@ parameter
-- needs to be inferrable from the function used.  For example:
-- 
-- > completePropertyListBy (\_ -> fail "parse error")
-- 
-- will be rejected by the compiler because it doesn't know what @b@ is.
--
-- Instead, say:
--
-- > completePropertyListBy (\_ -> fail "parse error" :: IO PropertyList)
-- 
-- (@b@ ~ 'Void' works too, or any other choice of @b@ satisfying the type 
-- context)
completePropertyListBy :: (Applicative f, PListCoalgebra Identity b)
    => (a -> f b) -> PartialPropertyList a -> f PropertyList
completePropertyListBy f = fmap completePropertyList . traverse f

-- |Exactly the same as 'completePropertyListBy', except using 'Monad' in
-- place of 'Applicative' (for situations where a 'Monad' is missing an
-- 'Applicative' instance and you'd rather not add an orphan, etc.)
completePropertyListByM :: (Monad m, PListCoalgebra Identity b)
    => (a -> m b) -> PartialPropertyList a -> m PropertyList
completePropertyListByM f = liftM completePropertyList . unwrapMonad . traverse (WrapMonad . f)

-- instance for Void to allow it to be used as @a@ in 'completePropertyList':
instance Functor f => PListCoalgebra f Void where
    plistCoalgebra = void